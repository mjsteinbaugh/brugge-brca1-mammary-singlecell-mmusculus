---
title: "Clustering"
author: "`r getOption('author')`"
date: "`r Sys.Date()`"
bibliography: bibliography.bib
params:
    bcbFile: "data/bcb.rda"
    pcCompute: 20
    pcUse: 10
    varsToRegress: !r c("nUMI", "mitoRatio", "S.Score", "G2M.Score")
    resolution: 0.6
    markersFile: "meta/markers.xlsx"
    outputDir: "."
---

```{r setup, cache=FALSE, message=FALSE, warning=FALSE}
library(bcbioSingleCell)

# Shared RMarkdown settings
prepareSingleCellTemplate()
if (file.exists("setup.R")) {
    source("setup.R")
}

# Load bcbio object
loadDataAsName(c(bcb = params$bcbFile))
bcbName <- basename(params$bcbFile) %>%
    # Remove file extension, if specified
    str_replace("\\.[A-Za-z0-9]+", "")

# Vector to use for plot looping
groupBy <- c("ident", "sampleName", "Phase", metadata(bcb)$interestingGroups)

# Directory paths
markersDir <- file.path(params$outputDir, "results", "markers")
dir.create(markersDir, recursive = TRUE, showWarnings = FALSE)

# Check for CPU-intensive saved objects
seuratInitialDataFile <-
    file.path("data", paste0(bcbDataFile, "SeuratInitial.rda"))
if (file.exists(seuratInitialDataFile)) {
    seuratInitialDataFile <- load(seuratInitialDataFile)
    seuratInitial <- get(seuratInitialDataFile)
    rm(list = seuratInitialDataFile)
    evalSeuratInitial <- FALSE
} else {
    evalSeuratInitial <- TRUE
}

seuratFinalDataFile <- file.path("data", paste0(bcbDataFile, "Seurat.rda"))
if (file.exists(seuratFinalDataFile)) {
    seuratFinalDataFile <- load(seuratFinalDataFile)
    seuratFinal <- get(seuratFinalDataFile)
    rm(list = seuratFinalDataFile)
    evalSeurat <- FALSE
} else {
    evalSeurat <- TRUE
}

markersDataFile <- file.path("data", paste0(bcbDataFile, "Markers.rda"))
if (file.exists(markersDataFile)) {
    markersDataFile <- load(markersDataFile)
    markers <- get(markersDataFile)
    rm(list = markersDataFile)
    evalMarkers <- FALSE
} else {
    evalMarkers <- TRUE
}
```

```{r header, child="_header.Rmd", eval=file.exists("_header.Rmd")}
```



This workflow is adapted from the [Seurat v2 Guided Clustering Tutorial](http://satijalab.org/seurat/pbmc3k_tutorial.html).



# Initialize Seurat (`r bcbName`)

Let's convert our `bcbioSCFiltered` object containing the filtered cellular barcodes into a `seurat` object. This step uses [Seurat][]'s `CreateSeuratObject()` with the same filtering cutoffs applied during our initial quality control analysis. Here we are imposing a basic minimum gene-cutoff, but also filtering low quality cells that have a high mitochondrial gene abundance.


## Normalize counts

When we initialize the `seurat` object, the raw counts stored in the `bcbioSCDataSet` are passed into the `seurat` object. Next, we automatically apply [Seurat][]'s default recommended normalization method. 
This employs global-scaling normalization with `LogNormalize()`, which (1) normalizes the gene expression measurements for each cell by the total expression, (2) multiplies this by a scale factor (10,000 by default), and (3) log-transforms the result.

```{r cache_seurat_initial, include=FALSE, eval=!evalSeuratInitial}
seurat <- seuratInitial
rm(seuratInitial)
```

```{r seurat, results="hide", eval=evalSeuratInitial}
seurat <- as(bcb, "seurat")
```



## Visualize cells

We applied cellular barcode filtering during our initial quality control analysis using `filterCells()`. Here we're using [Seurat][]'s `VlnPlot()` function to visualize the number of UMI counts (`nUMI`), genes detected (`nGene`), and relative mitochondrial abundance (`mitoRatio`).

```{r qc_plots_1}
features <- c("nUMI", "nGene", "mitoRatio")
sapply(seq_along(features), function(a) {
    JoyPlot(
        seurat,
        features.plot = features[[a]],
        x.lab.rot = TRUE) %>%
        show
    VlnPlot(
        seurat,
        features.plot = features[[a]],
        x.lab.rot = TRUE) %>%
        show
}) %>%
    invisible
```

Here we are visualizing UMI count correlations with genes detected (`nGene`) and mitochondrial abundance (`mitoRatio`). These scatterplots should resemble the figures presented in the quality control report.

```{r gene_plots}
GenePlot(seurat, "nUMI", "nGene")
GenePlot(seurat, "nUMI", "mitoRatio")
```



# Find variable genes

[Seurat][] calculates highly variable genes and focuses on these for downstream analysis. `FindVariableGenes()` calculates the average expression and dispersion for each gene, places these genes into bins, and then calculates a z-score for dispersion within each bin. This helps control for the relationship between variability and average expression.

```{r variable_gene_plot}
VariableGenePlot(seurat)
```



# Scale data and remove unwanted sources of variation

Your single cell dataset likely contains "uninteresting" sources of variation. This could include not only technical noise, but batch effects, or even biological sources of variation (cell cycle stage). As suggested in Buettner et al, NBT, 2015, regressing these signals out of the analysis can improve downstream dimensionality reduction and clustering. To mitigate the effect of these signals, [Seurat][] constructs linear models to predict gene expression based on user-defined variables. The scaled z-scored residuals of these models are stored in the `seurat@scale.data` slot, and are used for dimensionality reduction and clustering.

We can regress out cell-cell variation in gene expression driven by batch, cell alignment rate, the number of detected molecules, and mitochondrial gene expression. For cycling cells, we can also learn a "cell-cycle" score and regress this out as well. *Cell cycle regression is not always recommended*, especially if there may be a biological basis for the difference between clusters (e.g. differentiation).


## Cell-cycle scoring and regression

This section is adapted from the [Cell-Cycle Scoring and Regression](http://satijalab.org/seurat/cell_cycle_vignette.html) vignette written by Paul Hoffman.

First, we assign each cell a score, based on its expression of G2/M and S phase markers. These marker sets should be anticorrelated in their expression levels, and cells expressing neither are likely not cycling and in G1 phase.

We assign scores in the `CellCycleScoring()` function, which stores S and G2/M scores in `seurat@meta.data`, along with the predicted classification of each cell in either G2M, S or G1 phase. `CellCycleScoring()` can also set the identity of the Seurat object to the cell-cycle phase by passing `set.ident = TRUE` (the original identities are stored as `old.ident`). Please note that Seurat does not use the discrete classifications (G2M/G1/S) in downstream cell cycle regression. Instead, it uses the quantitative scores for G2M and S phase. However, we provide our predicted classifications in case they are of interest.

```{r cell_cycle_markers}
org <- str_match(metadata(bcb)$organism, "^([A-Z])[a-z]+ ([a-z]+)$") %>%
    .[, 2:3] %>%
    as.character %>%
    paste0(collapse = "")
ccm <- data(
    list = paste0("cellCycleMarkers", org),
    package = "bcbioSingleCell")
assign("ccm", get(ccm))

# Filter S and G2/M markers
s.genes <- filter(ccm, phase == "S") %>%
    pull("symbol")
g2m.genes <- filter(ccm, phase == "G2/M") %>%
    pull("symbol")

rm(ccm, org)
```

```{r cell_cycle_scoring, eval=evalSeuratInitial}
seurat <- CellCycleScoring(
    seurat,
    g2m.genes = g2m.genes,
    s.genes = s.genes)

# Cell-cycle `Phase` column is added to `seurat@meta.data`
# glimpse(seurat@meta.data)

assignAndSaveData(paste0(bcbName, "SeuratInitial"), seurat)
```

Here we are checking to see if the cells are grouping by cell cycle.

```{r cell_cycle_pca_1}
RunPCA(
    seurat,
    pc.genes = c(s.genes, g2m.genes),
    do.print = FALSE) %>%
    PCAPlot(group.by = "Phase")
```


## Apply cell-cell variability regression variables

Generally, we currently recommend scaling data to minimize the effects of variable read counts (`nUMI`) and mitochondrial abundance (`mitoRatio`) as a first approach. When regressing out the effects of cell-cycle variation, include `S.Score` and `G2M.Score` in the `vars.to.regress` argument.

```{r cache_seurat_final, include=FALSE, eval=!evalSeurat}
seurat <- seuratFinal
rm(seuratFinal)
```

```{r scale_data, results="hide", eval=evalSeurat}
seurat <- ScaleData(seurat, vars.to.regress = params$varsToRegress)
```

Now that regression has been applied, let's recheck to see if the cells are clustering by cycle. If the regression has worked, we should now see this go away.

```{r cell_cycle_pca_2}
RunPCA(
    seurat,
    pc.genes = c(s.genes, g2m.genes),
    do.print = FALSE) %>%
    PCAPlot(group.by = "Phase")
```



# Perform linear dimensional reduction

Next, we perform principal component analysis (PCA) on the scaled data with `RunPCA()`. By default, the genes in `seurat@var.genes` are used as input, but can be defined using pc.genes. We have typically found that running dimensionality reduction on highly variable genes can improve performance. However, with UMI data - particularly after regressing out technical variables, we often see that PCA returns similar (albeit slower) results when run on much larger subsets of genes, including the whole transcriptome.

`ProjectPCA()` scores each gene in the dataset (including genes not included in the PCA) based on their correlation with the calculated components. Though we don't use this further here, it can be used to identify markers that are strongly correlated with cellular heterogeneity, but may not have passed through variable gene selection.  The results of the projected PCA can be explored by setting `use.full = TRUE` for `PrintPCA()`.

```{r run_pca, eval=evalSeurat}
seurat <- seurat %>%
    RunPCA(do.print = FALSE) %>%
    ProjectPCA(do.print = FALSE)
```

```{r print_pca}
PrintPCA(
    seurat,
    pcs.print = 1:params$pcCompute)
```

We can visualize these genes graphically using `VizPCA()`.

```{r viz_pca, fig.height=30, fig.width=10}
VizPCA(seurat, pcs.use = 1:params$pcCompute, font.size = 1, nCol = 3)
```

In particular, `PCHeatmap()` allows for easy exploration of the primary sources of heterogeneity in a dataset, and can be useful when trying to decide which PCs to include for further downstream analyses. Both cells and genes are ordered according to their PCA scores. Setting `cells.use` to a number plots the "extreme" cells on both ends of the spectrum, which dramatically speeds plotting for large datasets. Though clearly a supervised analysis, we find this to be a valuable tool for exploring correlated gene sets.

```{r pc_heatmap, fig.height=30, fig.width=10}
PCHeatmap(seurat,
          do.balanced = TRUE,
          pc.use = 1:params$pcCompute)
```



# Determine statistically significant principal components

To overcome the extensive technical noise in any single gene for scRNA-seq data, [Seurat][] clusters cells based on their PCA scores, with each PC essentially representing a "metagene" that combines information across a correlated gene set. Determining how many PCs to include downstream is therefore an important step. To accomplish this, we plot the standard deviation of each PC as an elbow plot with `PCElbowPlot()`.

PC selection — identifying the true dimensionality of a dataset — is an important step for [Seurat][], but can be challenging/uncertain. We therefore suggest these three approaches to consider:

1. Supervised, exploring PCs to determine relevant sources of heterogeneity, and could be used in conjunction with GSEA for example.
2. Implement a statistical test based on a random null model. This can be time-consuming for large datasets, and may not return a clear PC cutoff.
3. **Heuristic approach**, using a metric that can be calculated instantly.

```{r pc_elbow_plot}
PCElbowPlot(seurat, num.pc = params$pcCompute) +
    ggtitle("pc elbow plot") +
    geom_line() +
    geom_vline(alpha = 0.5,
               color = "green",
               size = 2,
               xintercept = params$pcUse)
```



# Cluster the cells

Seurat now includes an graph-based clustering approach. Importantly, the *distance metric* which drives the clustering analysis (based on previously identified PCs) remains the same. However, our approach to partioning the cellular distance matrix into clusters has dramatically improved. Our approach was heavily inspired by recent manuscripts which applied graph-based clustering approaches to scRNA-seq data [SNN-Cliq, Xu and Su, Bioinformatics, 2015] and CyTOF data [PhenoGraph, Levine et al., Cell, 2015]. Briefly, these methods embed cells in a graph structure - for example a K-nearest neighbor (KNN) graph, with edges drawn between cells with similar gene expression patterns, and then attempt to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’. As in PhenoGraph, we first construct a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard distance). To cluster the cells, we apply modularity optimization techniques [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function.

The `FindClusters()` function implements the procedure, and contains a `resolution` argument that sets the "granularity" of the downstream clustering, with increased values leading to a greater number of clusters. We find that setting this parameter between `0.6`-`1.2` typically returns good results for single cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. The clusters are saved in the `seurat@ident` slot.

Regarding the value of the `resolution` argument, use a value `< 1` if you want to obtain fewer clusters.

```{r find_clusters, results="hide", eval=evalSeurat}
seurat <- FindClusters(
    seurat,
    dims.use = 1:params$pcUse,
    force.recalc = TRUE,
    print.output = TRUE,
    resolution = params$resolution,
    save.SNN = TRUE)
```

A useful feature in [Seurat][] v2.0 is the ability to recall the parameters that were used in the latest function calls for commonly used functions. For FindClusters, we provide the function PrintFindClustersParams to print a nicely formatted formatted summary of the parameters that were chosen.

```{r find_clusters_params}
PrintFindClustersParams(seurat)
```



# Run non-linear dimensional reduction (tSNE)

[Seurat][] continues to use tSNE as a powerful tool to visualize and explore these datasets. While we no longer advise clustering directly on tSNE components, cells within the graph-based clusters determined above should co-localize on the tSNE plot. This is because the tSNE aims to place cells with similar local neighborhoods in high-dimensional space together in low-dimensional space. As input to the tSNE, we suggest using the same PCs as input to the clustering analysis, although computing the tSNE based on scaled gene expression is also supported using the `genes.use` argument.

```{r run_tsne, results="hide", eval=evalSeurat}
seurat <- RunTSNE(
    seurat,
    dims.use = 1:params$pcUse,
    do.fast = TRUE)
assignAndSaveData(paste0(bcbName, "Seurat"), seurat)
```

```{r tsne_params}
PrintTSNEParams(seurat)
```

```{r tsne_plots}
sapply(seq_along(groupBy), function(a) {
    TSNEPlot(seurat,
             do.label = TRUE,
             group.by = groupBy[[a]],
             label.size = 6)
}) %>%
    invisible
```

Note that tSNE is not PCA! The measurement of distance in a tSNE plot is difficult to interpret, and is most helpful for the relationships of close neighbors. To better infer separation distance between the putative clusters, let's reapply PCA.

```{r pca_plot}
sapply(seq_along(groupBy), function(a) {
    PCAPlot(seurat,
            do.label = TRUE,
            group.by = groupBy[[a]])
}) %>%
    invisible
```



# Cluster quality control

Let's look at the variance in the number of UMI counts (`nUMI`), gene detection (`nGene`), and the percentage of mitochondrial gene expression (`mitoRatio`), to see if there are any obvious cluster artefacts.

```{r qc_plots_2}
# @seealso colnames(seurat@meta.data)
colors <- c("grey", "purple")
features <- c("nUMI", "nGene", "mitoRatio")
sapply(seq_along(features), function(a) {
    JoyPlot(
        seurat,
        features.plot = features[[a]],
        x.lab.rot = TRUE) %>%
        show
    VlnPlot(
        seurat,
        features.plot = features[[a]],
        x.lab.rot = TRUE) %>%
        show
    FeaturePlot(
        seurat,
        cols.use = colors,
        features.plot = features[[a]])
}) %>%
    invisible
```



# Find differentially expressed genes (cluster biomarkers)

Seurat can help you find markers that define clusters via differential expression. By default, it identifes positive and negative markers of a single cluster (specified in `ident.1`), compared to all other cells. `FindAllMarkers()` automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells.

The `min.pct` argument requires a gene to be detected at a minimum percentage in either of the two groups of cells, and the `thresh.test` argument requires a gene to be differentially expressed (on average) by some amount between the two groups. You can set both of these to 0, but with a dramatic increase in time - since this will test a large number of genes that are unlikely to be highly discriminatory. As another option to speed up these computations, `max.cells.per.ident` can be set. This will downsample each identity class to have no more cells than whatever this is set to. While there is generally going to be a loss in power, the speed increases can be significiant and the most highly differentially expressed genes will likely still rise to the top.

Seurat has four tests for differential expression which can be set with the `test.use` parameter: LRT test based on zero-inflated data (`bimod`, default), ROC test (`roc`), t-test (`t`), LRT test based on tobit-censoring models (`tobit`) The ROC test returns the 'classification power' for any individual marker (ranging from 0 - random, to 1 - perfect).

```{r find_all_markers, results="hide", eval=evalMarkers}
markers <- FindAllMarkers(
    seurat,
    latent.vars = params$varsToRegress)
assignAndSaveData(paste0(bcbName, "Markers"), markers)
write_csv(markers, file.path(markersDir, paste0(bcbName, ".csv.gz")))
```


## Top markers per cluster

```{r top_markers, results="asis"}
topMarkers <- topMarkers(markers, show = TRUE)
```



# Visualization

## Cluster heterogeneity

Heatmaps can also be a good way to examine heterogeneity within/between clusters. The `DoHeatmap()` function will generate a heatmap for given cells and genes. In this case, we are plotting the top markers for each cluster.

```{r cluster_heatmap, fig.height=12, fig.width=12}
DoHeatmap(
    seurat,
    genes.use = topMarkers$symbol,
    remove.key = TRUE,
    slim.col.label = TRUE)
```


## Cluster marker plots

There are several tools for visualizing marker expression:

- `VlnPlot()`: shows expression probability distributions across clusters.
- `FeaturePlot()`: visualizes gene expression on a tSNE or PCA plot.
- New functions: `JoyPlot()`, `CellPlot()`, `DotPlot()`.


## Top markers per cluster {.tabset}

```{r plot_top_markers, results="asis"}
plotTopMarkers(seurat, topMarkers, headerLevel = 3)
```



# Known marker analysis

## Load known markers

```{r known_markers, results="asis"}
knownMarkers <- readMarkers(
    params$markersFile,
    gene2symbol = metadata(bcb)$gene2symbol,
    show = TRUE)
saveData(knownMarkers)
```


## Known markers detected

Let's obtain the statistics on our known marker genes from [Seurat][].

```{r known_markers_detected, results="asis"}
knownMarkersDetected <- knownMarkersDetected(markers, knownMarkers, show = TRUE)
```


## Visualize cluster specificity {.tabset}

```{r plot_known_markers, results="asis"}
plotKnownMarkers(seurat, knownMarkersDetected, headerLevel = 3)
```



```{r footer, child="_footer.Rmd", eval=file.exists("_footer.Rmd")}
```
